---
// SearchInput component - displays search input and handles quick search
---

<div class="search-container">
  <div class="search-input-wrapper">
    <svg class="search-icon" width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
      <path d="M9 17A8 8 0 1 0 9 1a8 8 0 0 0 0 16Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
      <path d="m19 19-4.35-4.35" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
    </svg>
    <input
      type="search"
      id="search-input"
      class="search-input"
      placeholder="Search posts..."
      aria-label="Search blog posts"
      autocomplete="off"
    />
    <button class="search-clear" id="search-clear" aria-label="Clear search" style="display: none;">
      <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
        <path d="M12 4L4 12M4 4l8 8" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
      </svg>
    </button>
  </div>
  <div id="search-results" class="search-results" style="display: none;"></div>
</div>

<style>
  .search-container {
    position: relative;
    width: 100%;
    max-width: 600px;
    margin: 0 auto;
  }
  
  .search-input-wrapper {
    position: relative;
    display: flex;
    align-items: center;
  }
  
  .search-icon {
    position: absolute;
    left: 1rem;
    color: var(--color-text-secondary);
    pointer-events: none;
    z-index: 1;
  }
  
  .search-input {
    width: 100%;
    padding: 0.75rem 1rem 0.75rem 3rem;
    font-size: 1rem;
    background: var(--color-surface);
    border: 2px solid var(--color-border);
    border-radius: 8px;
    color: var(--color-text);
    transition: all var(--transition-fast);
  }
  
  .search-input:focus {
    outline: none;
    border-color: var(--color-accent);
    box-shadow: 0 0 0 3px rgba(var(--color-accent-rgb), 0.1);
  }
  
  .search-input::placeholder {
    color: var(--color-text-secondary);
  }
  
  .search-clear {
    position: absolute;
    right: 0.75rem;
    background: none;
    border: none;
    cursor: pointer;
    padding: 0.25rem;
    color: var(--color-text-secondary);
    display: flex;
    align-items: center;
    justify-content: center;
    transition: color var(--transition-fast);
  }
  
  .search-clear:hover {
    color: var(--color-text);
  }
  
  .search-results {
    position: absolute;
    top: calc(100% + 0.5rem);
    left: 0;
    right: 0;
    max-height: 70vh;
    overflow-y: auto;
    background: var(--color-surface);
    border: 2px solid var(--color-border);
    border-radius: 8px;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
    z-index: 1000;
    margin-top: 0.5rem;
  }
  
  [data-theme="dark"] .search-results {
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
  }
  
  @media (prefers-color-scheme: dark) {
    [data-theme="auto"] .search-results {
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    }
  }
  
  .search-result-item {
    padding: 1rem;
    border-bottom: 1px solid var(--color-border);
    cursor: pointer;
    transition: background var(--transition-fast);
  }
  
  .search-result-item:last-child {
    border-bottom: none;
  }
  
  .search-result-item:hover {
    background: var(--color-code-bg);
  }
  
  .search-result-title {
    font-weight: 600;
    color: var(--color-text);
    margin-bottom: 0.25rem;
    font-size: 1rem;
  }
  
  .search-result-description {
    font-size: 0.875rem;
    color: var(--color-text-secondary);
    margin-bottom: 0.5rem;
    line-height: 1.5;
  }
  
  .search-result-meta {
    display: flex;
    gap: 0.75rem;
    flex-wrap: wrap;
    font-size: 0.75rem;
    color: var(--color-text-secondary);
  }
  
  .search-result-tags {
    display: flex;
    gap: 0.5rem;
    flex-wrap: wrap;
  }
  
  .search-result-tag {
    padding: 0.125rem 0.5rem;
    background: var(--color-code-bg);
    border-radius: 4px;
    font-size: 0.75rem;
  }
  
  .search-result-date {
    font-size: 0.75rem;
  }
  
  .search-highlight {
    background: var(--color-accent);
    color: white;
    padding: 0.125rem 0.25rem;
    border-radius: 2px;
    font-weight: 600;
  }
  
  .search-no-results {
    padding: 2rem;
    text-align: center;
    color: var(--color-text-secondary);
  }
  
  .search-loading {
    padding: 2rem;
    text-align: center;
    color: var(--color-text-secondary);
  }
  
  @media (max-width: 768px) {
    .search-container {
      max-width: 100%;
    }
    
    .search-results {
      max-height: 60vh;
    }
  }
</style>

<script is:inline>
  (function() {
    if (typeof window === 'undefined') return;
    
    // Type definitions
    const SearchIndexItem = {
      title: '',
      description: '',
      content: '',
      tags: [],
      slug: '',
      date: '',
      excerpt: ''
    };
    
    let searchIndex = [];
    let fuse = null;
    let searchTimeout = null;
    let Fuse = null;
    
    // Load Fuse.js from CDN
    async function loadFuse() {
      if (window.Fuse) {
        Fuse = window.Fuse;
        return;
      }
      
      return new Promise((resolve, reject) => {
        if (document.querySelector('script[data-fuse-loaded]')) {
          // Wait for existing script to load
          const checkInterval = setInterval(() => {
            if (window.Fuse) {
              Fuse = window.Fuse;
              clearInterval(checkInterval);
              resolve();
            }
          }, 50);
          return;
        }
        
        const script = document.createElement('script');
        script.src = 'https://cdn.jsdelivr.net/npm/fuse.js@7.1.0/dist/fuse.min.js';
        script.async = true;
        script.setAttribute('data-fuse-loaded', 'true');
        
        script.onload = () => {
          Fuse = window.Fuse;
          resolve();
        };
        
        script.onerror = () => {
          console.error('Failed to load Fuse.js');
          reject();
        };
        
        document.head.appendChild(script);
      });
    }
    
    // Load search index
    async function loadSearchIndex() {
      try {
        // Try to load Fuse.js, but don't fail if it doesn't load
        try {
          await loadFuse();
        } catch (fuseError) {
          console.warn('Fuse.js failed to load, using basic search only:', fuseError);
        }
        
        const response = await fetch('/search-index.json');
        if (!response.ok) {
          throw new Error(`Failed to fetch search index: ${response.status} ${response.statusText}`);
        }
        
        searchIndex = await response.json();
        
        if (!Array.isArray(searchIndex) || searchIndex.length === 0) {
          console.warn('Search index is empty or invalid');
          return;
        }
        
        // Configure Fuse.js for fuzzy search (if available)
        if (Fuse && searchIndex.length > 0) {
          try {
            fuse = new Fuse(searchIndex, {
              keys: [
                { name: 'title', weight: 0.4 },
                { name: 'description', weight: 0.3 },
                { name: 'tags', weight: 0.2 },
                { name: 'content', weight: 0.1 },
              ],
              threshold: 0.4, // 0.0 = exact match, 1.0 = match anything
              includeScore: true,
              minMatchCharLength: 2,
            });
          } catch (fuseInitError) {
            console.warn('Failed to initialize Fuse.js, using basic search only:', fuseInitError);
            fuse = null;
          }
        }
      } catch (error) {
        console.error('Failed to load search index:', error);
        // Search will still work with empty index (will just show no results)
        searchIndex = [];
      }
    }
  
    // Highlight search terms in text
    function highlightText(text, query) {
      if (!query) return text;
      const regex = new RegExp(`(${query.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')})`, 'gi');
      return text.replace(regex, '<mark class="search-highlight">$1</mark>');
    }
    
    // Quick search (titles/tags only) - instant results
    function quickSearch(query) {
      if (!query || query.length < 2) return [];
      
      const lowerQuery = query.toLowerCase();
      return searchIndex.filter(item => {
        const titleMatch = item.title.toLowerCase().includes(lowerQuery);
        const tagMatch = item.tags.some(tag => tag.toLowerCase().includes(lowerQuery));
        return titleMatch || tagMatch;
      }).slice(0, 5); // Limit to 5 quick results
    }
  
    // Full-text search using Fuse.js
    function fullTextSearch(query) {
      if (!fuse || !query || query.length < 2) return [];
      return fuse.search(query).slice(0, 10); // Limit to 10 results
    }
  
    // Perform hybrid search
    function performSearch(query) {
      const resultsContainer = document.getElementById('search-results');
      const clearButton = document.getElementById('search-clear');
      
      if (!resultsContainer) {
        console.warn('Search results container not found');
        return;
      }
      
      if (!query || query.length < 2) {
        resultsContainer.style.display = 'none';
        if (clearButton) clearButton.style.display = 'none';
        return;
      }
      
      // Check if search index is loaded
      if (!searchIndex || searchIndex.length === 0) {
        resultsContainer.style.display = 'block';
        resultsContainer.innerHTML = '<div class="search-loading">Loading search index...</div>';
        // Try to load index if not already loaded
        loadSearchIndex().then(() => {
          // Retry search after index loads
          performSearch(query);
        });
        return;
      }
      
      if (clearButton) clearButton.style.display = 'block';
      
      // Show loading state
      resultsContainer.style.display = 'block';
      resultsContainer.innerHTML = '<div class="search-loading">Searching...</div>';
      
      // Use quick search for instant results, then enhance with full-text
      setTimeout(() => {
        try {
          const quickResults = quickSearch(query);
          const fullResults = fullTextSearch(query);
          
          // Combine results (quick results first, then full-text)
          const resultMap = new Map();
          
          // Add quick results first (higher priority)
          quickResults.forEach(item => {
            resultMap.set(item.slug, item);
          });
          
          // Add full-text results
          if (fullResults && fullResults.length > 0) {
            fullResults.forEach(result => {
              const item = result.item || result; // Handle both Fuse result format and direct items
              if (item && !resultMap.has(item.slug)) {
                resultMap.set(item.slug, item);
              }
            });
          }
          
          const allResults = Array.from(resultMap.values()).slice(0, 10);
          
          if (allResults.length === 0) {
            resultsContainer.innerHTML = '<div class="search-no-results">No posts found. Try different keywords.</div>';
            return;
          }
          
          // Render results
          resultsContainer.innerHTML = allResults.map(item => {
            const date = new Date(item.date).toLocaleDateString('en-US', {
              year: 'numeric',
              month: 'short',
              day: 'numeric'
            });
            
            return `
              <a href="/blog/${item.slug}" class="search-result-item">
                <div class="search-result-title">${highlightText(item.title, query)}</div>
                <div class="search-result-description">${highlightText(item.description || item.excerpt || '', query)}</div>
                <div class="search-result-meta">
                  <span class="search-result-date">${date}</span>
                  ${item.tags && item.tags.length > 0 ? `
                    <div class="search-result-tags">
                      ${item.tags.map(tag => `<span class="search-result-tag">${tag}</span>`).join('')}
                    </div>
                  ` : ''}
                </div>
              </a>
            `;
          }).join('');
        } catch (error) {
          console.error('Search error:', error);
          resultsContainer.innerHTML = '<div class="search-no-results">An error occurred while searching. Please try again.</div>';
        }
      }, 100); // Small delay to show loading state
    }
    
    // Initialize search on page load
    function initializeSearch() {
      loadSearchIndex();
      
      const searchInput = document.getElementById('search-input');
      const clearButton = document.getElementById('search-clear');
      const resultsContainer = document.getElementById('search-results');
      
      if (!searchInput) {
        // Retry if DOM not ready yet
        setTimeout(initializeSearch, 100);
        return;
      }
      
      // Debounced search
      searchInput.addEventListener('input', (e) => {
        const query = e.target.value.trim();
        
        if (searchTimeout) {
          clearTimeout(searchTimeout);
        }
        
        searchTimeout = setTimeout(() => {
          performSearch(query);
        }, 150);
      });
      
      // Clear search
      if (clearButton) {
        clearButton.addEventListener('click', () => {
          searchInput.value = '';
          if (resultsContainer) resultsContainer.style.display = 'none';
          if (clearButton) clearButton.style.display = 'none';
          searchInput.focus();
        });
      }
      
      // Close results when clicking outside
      document.addEventListener('click', (e) => {
        const target = e.target;
        const searchContainer = document.querySelector('.search-container');
        if (searchContainer && !searchContainer.contains(target)) {
          if (resultsContainer) resultsContainer.style.display = 'none';
        }
      });
      
      // Keyboard navigation
      searchInput.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
          if (resultsContainer) resultsContainer.style.display = 'none';
          searchInput.blur();
        }
      });
    }
    
    // Check if DOM is already loaded
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initializeSearch);
    } else {
      // DOM already loaded, initialize immediately
      initializeSearch();
    }
  })();
</script>

