---
/**
 * Ask Praveen.AI Chat Widget Component
 * 
 * Floating chat widget for blog posts that allows users to ask questions
 * about the content using RAG (Retrieval Augmented Generation).
 * 
 * Story 10.2: Chat Widget UI Component
 */

interface Props {
  currentUrl?: string;
  postTitle?: string;
}

const { currentUrl = typeof window !== 'undefined' ? window.location.pathname : '', postTitle = '' } = Astro.props;
---

<div id="ask-ai-chatbot" class="ask-ai-chatbot" data-current-url={currentUrl} data-post-title={postTitle}>
  <!-- Floating Toggle Button -->
  <button
    id="chatbot-toggle"
    class="chatbot-toggle"
    aria-label="Open Ask Praveen.AI chat"
    aria-expanded="false"
    aria-controls="chatbot-panel"
  >
    <svg class="chatbot-icon" width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
      <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
    </svg>
    <span class="chatbot-badge" id="chatbot-badge" aria-hidden="true">1</span>
  </button>

  <!-- Chat Panel -->
  <div
    id="chatbot-panel"
    class="chatbot-panel"
    role="dialog"
    aria-labelledby="chatbot-title"
    aria-modal="true"
    hidden
  >
    <!-- Header -->
    <div class="chatbot-header">
      <div class="chatbot-header-content">
        <h2 id="chatbot-title" class="chatbot-title">Ask Praveen.AI</h2>
        <p class="chatbot-subtitle">Ask questions about this post</p>
      </div>
      <div class="chatbot-header-actions">
        <button
          id="chatbot-refresh"
          class="chatbot-refresh"
          aria-label="Clear chat"
          type="button"
          title="Clear chat"
        >
          <svg width="18" height="18" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
            <path d="M3 6h14M6 6V4a2 2 0 012-2h4a2 2 0 012 2v2m3 0v10a2 2 0 01-2 2H5a2 2 0 01-2-2V6h14zM8 9v6M12 9v6" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
          </svg>
        </button>
        <button
          id="chatbot-close"
          class="chatbot-close"
          aria-label="Close chat"
          type="button"
        >
          <svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
            <path d="M15 5L5 15M5 5l10 10" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
          </svg>
        </button>
      </div>
    </div>

    <!-- Messages Container -->
    <div id="chatbot-messages" class="chatbot-messages" role="log" aria-live="polite" aria-atomic="false">
      <div class="chatbot-welcome">
        <p>Hi! I'm Praveen.AI. Ask me anything about this post, and I'll help you understand the content better.</p>
        <div class="chatbot-suggestions">
          <button class="suggestion-chip" data-suggestion="Summarize this post">Summarize this post</button>
          <button class="suggestion-chip" data-suggestion="What are the key takeaways?">Key takeaways</button>
          <button class="suggestion-chip" data-suggestion="Explain the main concepts">Explain concepts</button>
        </div>
      </div>
    </div>

    <!-- Input Area -->
    <div class="chatbot-input-area">
      <div class="chatbot-input-wrapper">
        <textarea
          id="chatbot-input"
          class="chatbot-input"
          placeholder="Ask a question about this post..."
          rows="1"
          aria-label="Type your question"
          aria-describedby="chatbot-input-help"
        ></textarea>
        <button
          id="chatbot-send"
          class="chatbot-send"
          type="button"
          aria-label="Send message"
          disabled
        >
          <svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
            <path d="M18 2L9 11M18 2l-7 7M18 2H12M18 2v6" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
          </svg>
        </button>
      </div>
      <p id="chatbot-input-help" class="chatbot-input-help" aria-live="polite">
        Press Enter to send, Shift+Enter for new line
      </p>
    </div>

  </div>
</div>

<script>
  /**
   * Ask Praveen.AI Chatbot Client
   * Handles UI interactions and API communication
   * 
   * Story 10.3: Integrated client-side RAG search
   */

  interface Message {
    id: string;
    role: 'user' | 'assistant';
    content: string;
    timestamp: Date;
    citations?: string[];
  }

  class AskAIChatbot {
    private panel: HTMLElement | null;
    private toggle: HTMLElement | null;
    private closeBtn: HTMLElement | null;
    private refreshBtn: HTMLElement | null;
    private messagesContainer: HTMLElement | null;
    private input: HTMLTextAreaElement | null;
    private sendBtn: HTMLButtonElement | null;
    private messages: Message[] = [];
    private isOpen = false;
    private currentUrl: string;
    private postTitle: string;
    private searchManager: any = null;
    private indexLoaded = false;
    private thinkingMessageId: string | null = null;
    private originalWelcomeElement: HTMLElement | null = null;

    constructor() {
      this.panel = document.getElementById('chatbot-panel');
      this.toggle = document.getElementById('chatbot-toggle');
      this.closeBtn = document.getElementById('chatbot-close');
      this.refreshBtn = document.getElementById('chatbot-refresh');
      this.messagesContainer = document.getElementById('chatbot-messages');
      this.input = document.getElementById('chatbot-input') as HTMLTextAreaElement;
      this.sendBtn = document.getElementById('chatbot-send') as HTMLButtonElement;

      const container = document.getElementById('ask-ai-chatbot');
      this.currentUrl = container?.dataset.currentUrl || window.location.pathname;
      this.postTitle = container?.dataset.postTitle || '';

      // Store reference to original welcome element to preserve scoped styles
      const originalWelcome = this.messagesContainer?.querySelector('.chatbot-welcome');
      if (originalWelcome) {
        this.originalWelcomeElement = originalWelcome.cloneNode(true) as HTMLElement;
      }

      this.init();
    }

    private async loadSearchManager(): Promise<void> {
      if (this.searchManager) return; // Already loaded
      
      try {
        // Dynamic import - Astro will bundle this correctly
        // Use relative path from component location
        const searchModule = await import('../utils/rag-search');
        
        if (searchModule && searchModule.getRAGSearchManager) {
          this.searchManager = searchModule.getRAGSearchManager();
          console.log('âœ… RAG search manager loaded successfully');
        } else {
          console.warn('âš ï¸ getRAGSearchManager export not found, available exports:', Object.keys(searchModule || {}));
          throw new Error('getRAGSearchManager export not found in rag-search module');
        }
      } catch (error) {
        console.error('âŒ Failed to load RAG search manager:', error);
        if (error instanceof Error) {
          console.error('Error message:', error.message);
          console.error('Error stack:', error.stack);
          // Check if it's a module resolution error
          if (error.message.includes('Failed to fetch') || error.message.includes('Cannot find module')) {
            console.error('ðŸ’¡ This might be a module bundling issue. The search will be disabled, but the API will still work.');
          }
        }
        // Don't throw - allow chat to work without search (will call API directly)
        this.searchManager = null;
      }
    }

    private init(): void {
      if (!this.panel || !this.toggle || !this.input) return;

      // Toggle button
      this.toggle.addEventListener('click', () => this.togglePanel());
      
      // Close button - use event delegation for maximum reliability
      // This works even if the button isn't found initially
      if (this.panel) {
        this.panel.addEventListener('click', (e) => {
          const target = e.target as HTMLElement;
          // Check if click is on close button or its children (SVG)
          if (target && (target.id === 'chatbot-close' || target.closest('#chatbot-close'))) {
            e.preventDefault();
            e.stopPropagation();
            console.log('Close button clicked');
            this.closePanel();
            return false;
          }
        });
        console.log('âœ… Close button event delegation attached');
      }
      
      // Also attach direct listener if button exists
      if (!this.closeBtn) {
        this.closeBtn = document.getElementById('chatbot-close');
      }
      
      if (this.closeBtn) {
        this.closeBtn.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();
          console.log('Close button clicked (direct)');
          this.closePanel();
        });
        console.log('âœ… Close button direct listener attached');
      }

      // Input handling
      this.input.addEventListener('input', () => this.handleInputChange());
      this.input.addEventListener('keydown', (e) => this.handleKeyDown(e));
      this.sendBtn?.addEventListener('click', () => this.sendMessage());

      // Suggestion chips
      document.querySelectorAll('.suggestion-chip').forEach(chip => {
        chip.addEventListener('click', (e) => {
          const suggestion = (e.target as HTMLElement).dataset.suggestion;
          if (suggestion && this.input) {
            this.input.value = suggestion;
            this.input.focus();
            this.handleInputChange();
            this.sendMessage();
          }
        });
      });

      // Refresh button
      if (this.refreshBtn) {
        this.refreshBtn.addEventListener('click', () => {
          this.clearChat();
        });
      }

      // Close on Escape
      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && this.isOpen) {
          this.closePanel();
        }
      });

      // Auto-resize textarea
      this.input.addEventListener('input', () => {
        this.autoResizeTextarea();
      });
    }

    private togglePanel(): void {
      if (this.isOpen) {
        this.closePanel();
      } else {
        this.openPanel();
      }
    }

    private async openPanel(): Promise<void> {
      if (!this.panel || !this.toggle) return;
      
      // Clear any previous loading state immediately
      this.hideLoading();
      
      this.panel.hidden = false;
      this.panel.style.display = ''; // Remove inline display style
      this.toggle.setAttribute('aria-expanded', 'true');
      this.isOpen = true;
      
      // Ensure search manager is loaded (don't show loading for this)
      // Use try-finally to ensure loading state is always cleared
      try {
        if (!this.searchManager) {
          try {
            await this.loadSearchManager();
          } catch (error) {
            console.warn('âš ï¸ Search manager load failed, continuing without search:', error);
            // Don't show error - chat can work without search
          }
        }
        
        // Load RAG index if not already loaded (don't show loading for this)
        if (this.searchManager && !this.indexLoaded) {
          try {
            await this.searchManager.loadIndex(this.currentUrl);
            this.indexLoaded = true;
            console.log('âœ… RAG index ready for search');
          } catch (error) {
            // Silently handle index load failures - chat can work without client-side search
            console.warn('âš ï¸ Failed to load RAG index (chat will work without client-side search):', error);
            if (error instanceof Error) {
              console.warn('Index load error details:', error.message);
            }
            // Mark as "loaded" (even though it failed) to prevent retry attempts
            // This prevents the error from propagating and showing user-facing errors
            this.indexLoaded = true;
          }
        }
      } finally {
        // Always ensure loading is cleared after async operations
        this.hideLoading();
      }
      
      // Focus input
      setTimeout(() => {
        this.input?.focus();
      }, 100);

      // Update badge
      this.updateBadge(0);
    }

    private closePanel(): void {
      console.log('closePanel called', { panel: !!this.panel, toggle: !!this.toggle, isOpen: this.isOpen });
      
      if (!this.panel || !this.toggle) {
        console.error('Cannot close: missing panel or toggle', { panel: !!this.panel, toggle: !!this.toggle });
        return;
      }
      
      // Clear loading state when closing
      this.hideLoading();
      
      // Set hidden attribute
      this.panel.hidden = true;
      // Also set display none via style to ensure it's hidden
      this.panel.style.display = 'none';
      this.toggle.setAttribute('aria-expanded', 'false');
      this.isOpen = false;
      
      console.log('Panel closed successfully', { hidden: this.panel.hidden, display: this.panel.style.display });
    }

    private handleInputChange(): void {
      if (!this.input || !this.sendBtn) return;
      
      const hasText = this.input.value.trim().length > 0;
      this.sendBtn.disabled = !hasText;
    }

    private handleKeyDown(e: KeyboardEvent): void {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        if (this.input?.value.trim()) {
          this.sendMessage();
        }
      }
    }

    private autoResizeTextarea(): void {
      if (!this.input) return;
      
      this.input.style.height = 'auto';
      const maxHeight = 120; // ~6 lines
      const newHeight = Math.min(this.input.scrollHeight, maxHeight);
      this.input.style.height = `${newHeight}px`;
    }

    private async sendMessage(): Promise<void> {
      if (!this.input || !this.input.value.trim()) return;

      const query = this.input.value.trim();
      this.input.value = '';
      this.handleInputChange();
      this.autoResizeTextarea();

      // Add user message
      this.addMessage('user', query);

      // Show loading
      this.showLoading();

        try {
          // Story 10.3: Search for relevant chunks using client-side Lunr search
          let chunkResults: any[] = [];
          let chunkIds: string[] = [];
          let citations: string[] = [];
          let searchSuccess = false;

          try {
            // Ensure search manager is loaded
            if (!this.searchManager) {
              await this.loadSearchManager();
            }

            if (this.searchManager) {
              try {
                // Ensure index is loaded (pass current URL for optimized loading)
                if (!this.indexLoaded) {
                  try {
                    await this.searchManager.loadIndex(this.currentUrl);
                    this.indexLoaded = true;
                  } catch (loadError) {
                    // Silently handle load failures - don't retry or show errors
                    console.warn('âš ï¸ Index load failed during search (continuing without search):', loadError);
                    this.indexLoaded = true; // Mark as "loaded" to prevent retries
                  }
                }

                // Only search if index is actually loaded
                if (this.indexLoaded && this.searchManager.isLoaded()) {
                  // Search for relevant chunks (smart search: current post first, then all posts)
                  chunkResults = await this.searchManager.searchChunksSmart(
                    query,
                    this.currentUrl,
                    5 // Top 5 chunks
                  );

                  // Extract chunk IDs and citations
                  chunkIds = chunkResults.map((chunk: any) => chunk.chunkId);
                  citations = chunkResults.map((chunk: any) => chunk.postUrl);
                  searchSuccess = true;

                  console.log(`ðŸ” Found ${chunkResults.length} relevant chunks for query: "${query}"`);
                  
                  if (chunkResults.length > 0) {
                    console.log('Top chunks:', chunkResults.map((c: any) => ({
                      post: c.postTitle,
                      score: c.score.toFixed(3),
                    })));
                  }
                } else {
                  console.log('â„¹ï¸ Index not loaded, skipping client-side search (API will handle it)');
                }
              } catch (indexError) {
                // Silently handle search errors - API can still work
                console.warn('âš ï¸ Search error (continuing without search results):', indexError);
                // Continue without search results - API will handle the query
              }
            } else {
              console.log('â„¹ï¸ Search manager not available, API will handle the query');
            }
          } catch (searchError) {
            console.warn('âš ï¸ Search error (continuing anyway):', searchError);
            // Continue without chunks - show helpful message
          }

          // Story 10.4: Call API endpoint with chunkIds (even if empty, API can handle it)
          let apiCallSuccess = false;
          try {
            // Detect if we're in local dev without Netlify dev server
            const isLocalDev = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';
            const port = window.location.port || (window.location.protocol === 'https:' ? '443' : '80');
            const isNetlifyDev = port === '8888' || port === '9999';
            const apiUrl = isLocalDev && !isNetlifyDev
              ? 'http://localhost:8888/api/chat' // Try Netlify dev default port
              : '/api/chat';
            
            const apiResponse = await fetch(apiUrl, {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
              },
              body: JSON.stringify({
                query,
                currentUrl: this.currentUrl,
                chunkIds: chunkIds.length > 0 ? chunkIds : [], // API can handle empty array
              }),
            });

            if (!apiResponse.ok) {
              // Try to get error message from response
              let errorMessage = `HTTP ${apiResponse.status}`;
              try {
                const errorData = await apiResponse.json();
                errorMessage = errorData.error || errorMessage;
              } catch (e) {
                // Response is not JSON, use status text
                errorMessage = apiResponse.statusText || errorMessage;
              }
              
              if (apiResponse.status === 404) {
                // API endpoint not found - likely running astro dev without netlify dev
                errorMessage = `API endpoint not found. Please run \`netlify dev\` instead of \`astro dev\` to enable the chat API, or use the production site.`;
              } else if (apiResponse.status === 429) {
                // Rate limited
                const retryAfter = apiResponse.headers.get('Retry-After');
                errorMessage = `Rate limit exceeded. Please wait ${retryAfter || 'a moment'} before trying again.`;
              }
              
              // Show API error message directly
              this.addMessage('assistant', `**API Error:** ${errorMessage}\n\nThe API endpoint is not available. ${apiResponse.status === 404 ? 'Make sure to run `netlify dev` for local development.' : 'This might be a temporary issue. Please try again.'}`, []);
              this.hideLoading();
              return;
            }

            const data = await apiResponse.json();
            
            if (!data.success) {
              // API returned success: false
              const errorMsg = data.error || 'The API returned an error response';
              this.addMessage('assistant', `**API Response:** ${errorMsg}\n\nPlease check the browser console (F12) for more details.`, []);
              this.hideLoading();
              return;
            }

            // Use API response - success!
            const answer = data.answer || 'No answer provided';
            const apiCitations = data.citations || citations;
            
            this.addMessage('assistant', answer, apiCitations);
            this.hideLoading();
            apiCallSuccess = true;
            return;
          } catch (apiError) {
            console.error('API call error:', apiError);
            // Network error or other exception
            const errorMsg = apiError instanceof Error ? apiError.message : 'Network error';
            this.addMessage('assistant', `**Connection Error:** ${errorMsg}\n\nUnable to reach the API endpoint. Please check your connection and try again.`, []);
            this.hideLoading();
            return;
          }
          
          // This code should never be reached - API call always returns above
          // But keep as safety net
          console.error('âš ï¸ Unexpected: API call did not return');
          this.addMessage('assistant', 'Unexpected error: API call did not complete. Please check the browser console (F12) for details.', []);
          this.hideLoading();
        } catch (error) {
          console.error('âŒ Send message error:', error);
          this.hideLoading();
          
          // Provide helpful error message
          let errorMessage = 'Something went wrong. Please try again.';
          
          if (error instanceof Error) {
            console.error('Error details:', {
              message: error.message,
              stack: error.stack,
              name: error.name
            });
            
            // Provide more specific error messages
            if (error.message.includes('Failed to load') || error.message.includes('fetch')) {
              errorMessage = 'Unable to load search index. The RAG index may not be available yet. This is a partial implementation (Story 10.3).';
            } else if (error.message.includes('import')) {
              errorMessage = 'Unable to load search module. Please refresh the page and try again.';
            } else {
              errorMessage = `Error: ${error.message}. This is a partial implementation. Check browser console (F12) for details.`;
            }
          }
          
          this.showError(errorMessage);
        }
    }

    private addMessage(role: 'user' | 'assistant', content: string, citations?: string[]): void {
      if (!this.messagesContainer) return;

      const message: Message = {
        id: `msg-${Date.now()}-${Math.random()}`,
        role,
        content,
        timestamp: new Date(),
        citations,
      };

      this.messages.push(message);

      // Remove welcome message if present
      const welcome = this.messagesContainer.querySelector('.chatbot-welcome');
      if (welcome) {
        welcome.remove();
      }

      // Create message element
      const messageEl = document.createElement('div');
      messageEl.className = `chatbot-message chatbot-message-${role}`;
      messageEl.setAttribute('data-message-id', message.id);

      const contentEl = document.createElement('div');
      contentEl.className = 'chatbot-message-content';
      
      if (role === 'user') {
        contentEl.textContent = content;
      } else {
        // Format assistant response with markdown-like formatting
        contentEl.innerHTML = this.formatResponse(content);
        
        // Add citations if present
        if (citations && citations.length > 0) {
          const citationsEl = document.createElement('div');
          citationsEl.className = 'chatbot-citations';
          citationsEl.innerHTML = `<strong>Sources:</strong> ${citations.map((c, i) => `<a href="${c}" target="_blank" rel="noopener">[${i + 1}]</a>`).join(' ')}`;
          contentEl.appendChild(citationsEl);
        }
      }

      messageEl.appendChild(contentEl);
      this.messagesContainer.appendChild(messageEl);

      // Scroll to bottom
      this.messagesContainer.scrollTop = this.messagesContainer.scrollHeight;

      // Update badge
      this.updateBadge(0);
    }

    private formatResponse(text: string): string {
      // Simple markdown-like formatting
      return text
        .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
        .replace(/\*(.*?)\*/g, '<em>$1</em>')
        .replace(/`(.*?)`/g, '<code>$1</code>')
        .replace(/\n/g, '<br>');
    }

    private showLoading(): void {
      // Show thinking message in chat window
      if (!this.messagesContainer) return;
      
      // Remove any existing thinking message
      this.hideLoading();
      
      // Create thinking message
      const thinkingId = `thinking-${Date.now()}`;
      this.thinkingMessageId = thinkingId;
      
      const messageEl = document.createElement('div');
      messageEl.className = 'chatbot-message chatbot-message-assistant chatbot-message-thinking';
      messageEl.setAttribute('data-message-id', thinkingId);
      
      const contentEl = document.createElement('div');
      contentEl.className = 'chatbot-message-content';
      contentEl.innerHTML = '<div class="loading-spinner-inline"></div><span>Thinking...</span>';
      
      messageEl.appendChild(contentEl);
      this.messagesContainer.appendChild(messageEl);
      
      // Scroll to bottom
      this.messagesContainer.scrollTop = this.messagesContainer.scrollHeight;
      
      // Disable send button
      if (this.sendBtn) {
        this.sendBtn.disabled = true;
      }
    }

    private hideLoading(): void {
      // Remove thinking message from chat
      if (this.thinkingMessageId && this.messagesContainer) {
        const thinkingEl = this.messagesContainer.querySelector(`[data-message-id="${this.thinkingMessageId}"]`);
        if (thinkingEl) {
          thinkingEl.remove();
        }
        this.thinkingMessageId = null;
      }
      
      // Re-enable send button
      if (this.sendBtn && this.input) {
        this.sendBtn.disabled = !this.input.value.trim();
      }
    }

    private showError(message: string): void {
      // Show error as a message in chat window
      this.addMessage('assistant', `**Error:** ${message}`, []);
    }

    private clearChat(): void {
      // Clear all messages including welcome
      if (!this.messagesContainer) return;
      
      // Remove thinking message if present
      this.hideLoading();
      
      // Remove all messages (but keep welcome structure if it exists)
      const messages = this.messagesContainer.querySelectorAll('.chatbot-message');
      messages.forEach(msg => msg.remove());
      
      // Clear messages array
      this.messages = [];
      this.thinkingMessageId = null;
      
      // Always remove and recreate welcome to ensure clean state
      const existingWelcome = this.messagesContainer.querySelector('.chatbot-welcome');
      if (existingWelcome) {
        existingWelcome.remove();
      }
      
      // Clone the original welcome element to preserve all scoped styles and class names
      let welcome: HTMLElement | null = null;
      
      if (this.originalWelcomeElement) {
        // Clone the stored original welcome element (preserves all Astro scoped styles)
        welcome = this.originalWelcomeElement.cloneNode(true) as HTMLElement;
        this.messagesContainer.appendChild(welcome);
      } else {
        // Fallback: if original wasn't stored, create it (shouldn't happen, but safety)
        const welcomeHTML = `
          <div class="chatbot-welcome">
            <p>Hi! I'm Praveen.AI. Ask me anything about this post, and I'll help you understand the content better.</p>
            <div class="chatbot-suggestions">
              <button class="suggestion-chip" data-suggestion="Summarize this post">Summarize this post</button>
              <button class="suggestion-chip" data-suggestion="What are the key takeaways?">Key takeaways</button>
              <button class="suggestion-chip" data-suggestion="Explain the main concepts">Explain concepts</button>
            </div>
          </div>
        `;
        this.messagesContainer.insertAdjacentHTML('beforeend', welcomeHTML);
        welcome = this.messagesContainer.querySelector('.chatbot-welcome');
      }
      
      // Re-attach suggestion chip listeners to the cloned/created welcome element
      if (welcome) {
        welcome.querySelectorAll('.suggestion-chip').forEach(chip => {
          chip.addEventListener('click', (e) => {
            e.preventDefault();
            const suggestion = (e.target as HTMLElement).getAttribute('data-suggestion');
            if (suggestion && this.input) {
              this.input.value = suggestion;
              this.input.focus();
              this.handleInputChange();
              this.sendMessage();
            }
          });
        });
      }
      
      // Clear input
      if (this.input) {
        this.input.value = '';
        this.handleInputChange();
      }
      
      // Update badge
      this.updateBadge(0);
    }

    private updateBadge(count: number): void {
      const badge = document.getElementById('chatbot-badge');
      if (badge) {
        if (count > 0) {
          badge.textContent = count.toString();
          badge.hidden = false;
        } else {
          badge.hidden = true;
        }
      }
    }
  }

  // Initialize when DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
      new AskAIChatbot();
    });
  } else {
    new AskAIChatbot();
  }
</script>

<style>
  .ask-ai-chatbot {
    position: fixed;
    /* Position above scroll buttons: scroll buttons are 2 buttons (44px each) + gap (0.5rem) + bottom margin (1.5rem) = ~116px */
    bottom: calc(44px + 0.5rem + 44px + 1.5rem + 1rem); /* Above scroll buttons with 1rem margin */
    right: 1.5rem;
    z-index: 1000;
    font-family: var(--font-sans);
  }

  /* Toggle Button */
  .chatbot-toggle {
    width: 56px;
    height: 56px;
    border-radius: 50%;
    background: var(--color-accent);
    color: white;
    border: none;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 4px 12px rgba(37, 99, 235, 0.3);
    transition: all var(--transition-base);
    position: relative;
  }

  .chatbot-toggle:hover {
    background: var(--color-accent-hover);
    transform: translateY(-2px);
    box-shadow: 0 6px 16px rgba(37, 99, 235, 0.4);
  }

  .chatbot-toggle:active {
    transform: translateY(0);
  }

  .chatbot-toggle:focus-visible {
    outline: 2px solid var(--color-accent);
    outline-offset: 4px;
  }

  .chatbot-icon {
    width: 24px;
    height: 24px;
  }

  .chatbot-badge {
    position: absolute;
    top: -4px;
    right: -4px;
    background: #ef4444;
    color: white;
    font-size: 0.75rem;
    font-weight: 600;
    width: 20px;
    height: 20px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    border: 2px solid var(--color-surface);
  }

  .chatbot-badge[hidden] {
    display: none;
  }

  /* Chat Panel */
  .chatbot-panel {
    position: absolute;
    bottom: calc(100% + 1rem);
    right: 0;
    width: 400px;
    max-width: calc(100vw - 2rem);
    height: 700px;
    max-height: calc(100vh - 6rem);
    background: var(--color-surface);
    border: 1px solid var(--color-border);
    border-radius: 12px;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.12);
    display: flex;
    flex-direction: column;
    overflow: hidden;
    animation: slideUp 0.3s ease-out;
  }

  .chatbot-panel[hidden] {
    display: none !important;
  }

  @keyframes slideUp {
    from {
      opacity: 0;
      transform: translateY(20px);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }

  /* Header */
  .chatbot-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 1rem 1.25rem;
    border-bottom: 1px solid var(--color-border);
    background: var(--color-surface);
  }

  .chatbot-header-content {
    flex: 1;
  }

  .chatbot-header-actions {
    display: flex;
    align-items: center;
    gap: 0.5rem;
  }

  .chatbot-title {
    font-size: 1.125rem;
    font-weight: 600;
    margin: 0 0 0.25rem 0;
    color: var(--color-text);
  }

  .chatbot-subtitle {
    font-size: 0.875rem;
    color: var(--color-text-secondary);
    margin: 0;
  }

  .chatbot-refresh,
  .chatbot-close {
    width: 32px;
    height: 32px;
    border: none;
    background: transparent;
    color: var(--color-text-secondary);
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 6px;
    transition: all var(--transition-fast);
    flex-shrink: 0;
    position: relative;
    z-index: 10;
    pointer-events: auto;
    -webkit-tap-highlight-color: transparent;
  }

  .chatbot-refresh:hover,
  .chatbot-close:hover {
    background: var(--color-code-bg);
    color: var(--color-text);
  }

  .chatbot-refresh:focus-visible,
  .chatbot-close:focus-visible {
    outline: 2px solid var(--color-accent);
    outline-offset: 2px;
  }

  /* Messages */
  .chatbot-messages {
    flex: 1;
    overflow-y: auto;
    padding: 1rem;
    display: flex;
    flex-direction: column;
    gap: 1rem;
    scroll-behavior: smooth;
  }

  .chatbot-messages::-webkit-scrollbar {
    width: 6px;
  }

  .chatbot-messages::-webkit-scrollbar-track {
    background: transparent;
  }

  .chatbot-messages::-webkit-scrollbar-thumb {
    background: var(--color-border);
    border-radius: 3px;
  }

  .chatbot-messages::-webkit-scrollbar-thumb:hover {
    background: var(--color-text-tertiary);
  }

  .chatbot-welcome {
    padding: 1rem;
    background: var(--color-code-bg);
    border-radius: 8px;
    color: var(--color-text-secondary);
    font-size: 0.9375rem;
    line-height: 1.6;
  }

  .chatbot-suggestions {
    display: flex;
    flex-wrap: wrap;
    gap: 0.5rem;
    margin-top: 0.75rem;
  }

  .suggestion-chip {
    padding: 0.5rem 0.75rem;
    background: var(--color-surface);
    border: 1px solid var(--color-border);
    border-radius: 6px;
    font-size: 0.875rem;
    color: var(--color-text);
    cursor: pointer;
    transition: all var(--transition-fast);
    font-family: var(--font-sans);
  }

  .suggestion-chip:hover {
    background: var(--color-code-bg);
    border-color: var(--color-accent);
    color: var(--color-accent);
  }

  .suggestion-chip:focus-visible {
    outline: 2px solid var(--color-accent);
    outline-offset: 2px;
  }

  .chatbot-message {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
    animation: fadeIn 0.3s ease-out;
  }

  .chatbot-message-user {
    align-items: flex-end;
  }

  .chatbot-message-assistant {
    align-items: flex-start;
  }

  .chatbot-message-content {
    max-width: 85%;
    padding: 0.75rem 1rem;
    border-radius: 12px;
    font-size: 0.9375rem;
    line-height: 1.6;
    word-wrap: break-word;
  }

  .chatbot-message-user .chatbot-message-content {
    background: var(--color-accent);
    color: white;
    border-bottom-right-radius: 4px;
  }

  .chatbot-message-assistant .chatbot-message-content {
    background: var(--color-code-bg);
    color: var(--color-text);
    border-bottom-left-radius: 4px;
  }

  .chatbot-message-thinking .chatbot-message-content {
    display: flex;
    align-items: center;
    gap: 0.75rem;
    color: var(--color-text-secondary);
  }

  .loading-spinner-inline {
    width: 16px;
    height: 16px;
    border: 2px solid var(--color-border);
    border-top-color: var(--color-accent);
    border-radius: 50%;
    animation: spin 0.8s linear infinite;
    flex-shrink: 0;
  }

  .chatbot-message-content code {
    background: rgba(0, 0, 0, 0.1);
    padding: 0.125rem 0.25rem;
    border-radius: 3px;
    font-size: 0.875em;
  }

  .chatbot-message-assistant .chatbot-message-content code {
    background: rgba(0, 0, 0, 0.1);
  }

  .chatbot-citations {
    margin-top: 0.5rem;
    padding-top: 0.5rem;
    border-top: 1px solid var(--color-border);
    font-size: 0.8125rem;
    color: var(--color-text-secondary);
  }

  .chatbot-citations a {
    color: var(--color-accent);
    text-decoration: underline;
    margin: 0 0.25rem;
  }

  /* Input Area */
  .chatbot-input-area {
    padding: 1rem;
    border-top: 1px solid var(--color-border);
    background: var(--color-surface);
  }

  .chatbot-input-wrapper {
    display: flex;
    align-items: flex-end;
    gap: 0.5rem;
    background: var(--color-code-bg);
    border: 1px solid var(--color-border);
    border-radius: 8px;
    padding: 0.5rem;
    transition: border-color var(--transition-fast);
  }

  .chatbot-input-wrapper:focus-within {
    border-color: var(--color-accent);
    outline: 2px solid transparent;
    outline-offset: 2px;
  }

  .chatbot-input {
    flex: 1;
    border: none;
    background: transparent;
    color: var(--color-text);
    font-family: var(--font-sans);
    font-size: 0.9375rem;
    line-height: 1.5;
    resize: none;
    overflow-y: auto;
    min-height: 24px;
    max-height: 120px;
    padding: 0.25rem 0.5rem;
  }

  .chatbot-input:focus {
    outline: none;
  }

  .chatbot-input::placeholder {
    color: var(--color-text-tertiary);
  }

  .chatbot-send {
    width: 32px;
    height: 32px;
    border: none;
    background: var(--color-accent);
    color: white;
    border-radius: 6px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all var(--transition-fast);
    flex-shrink: 0;
  }

  .chatbot-send:hover:not(:disabled) {
    background: var(--color-accent-hover);
  }

  .chatbot-send:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  .chatbot-send:focus-visible {
    outline: 2px solid var(--color-accent);
    outline-offset: 2px;
  }

  .chatbot-input-help {
    font-size: 0.75rem;
    color: var(--color-text-tertiary);
    margin: 0.5rem 0 0 0;
    text-align: center;
  }

  @keyframes spin {
    to { transform: rotate(360deg); }
  }

  /* Responsive */
  @media (max-width: 768px) {
    .ask-ai-chatbot {
      /* On mobile, scroll buttons are smaller (40px each) and positioned at var(--space-sm) */
      bottom: calc(40px + 0.5rem + 40px + 1rem + 0.75rem); /* Above scroll buttons with margin */
      right: 1rem;
    }
    
    .chatbot-panel {
      width: calc(100vw - 2rem);
      height: calc(100vh - 4rem);
      max-height: calc(100vh - 4rem);
      bottom: calc(100% + 0.5rem);
    }
    
    .chatbot-toggle {
      width: 48px;
      height: 48px;
    }
    
    .chatbot-icon {
      width: 20px;
      height: 20px;
    }
  }

  @media (max-width: 480px) {
    .chatbot-panel {
      width: 100vw;
      height: 100vh;
      max-height: 100vh;
      border-radius: 0;
      bottom: 0;
      right: 0;
    }
  }
</style>
